# libpcap原理及使用

libpcap（Packet Capture Library）即数据包捕获函数库，是Unix/Linux平台下的网络数据包捕获函数库。它是一个独立于系统的用户层包捕获的API接口，为底层网络监测提供了一个可移植的框架。著名的软件TCPDUMP就是在libpcap的的基础上开发而成的

libpcap可以实现以下功能：

* 数据包捕获：捕获流经网卡的原始数据包

* 自定义数据包发送：任何构造格式的原始数据包

* 流量采集与统计：网络采集的中流量信息

* 规则过滤：提供自带规则过滤功能，按需要选择过滤规则

libpcap工作原理

libpcap主要由两部份组成：网络分接口\(Network Tap\)和数据过滤器\(Packet Filter\)。

网络分接口从网络设备驱动程序中收集数据拷贝（旁路机制），过滤器决定是否接收该数据包。Libpcap利用BSD Packet Filter\(BPF\)算法对网卡接收到的链路层数据包进行过滤。BPF算法的基本思想是在有BPF监听的网络中，网卡驱动将接收到的数据包复制一份交给BPF过滤器，过滤器根据用户定义的规则决定是否接收此数据包以及需要拷贝该数据包的那些内容，然后将过滤后的数据给与过滤器相关联的上层应用程序。如果没有定义规则，则把全部数据交给上层应用程序。

![](/assets/libpcap.png)

如图所示一个数据包的捕捉分为三个主要部分：

* 面向底层包捕获、

* 面向中间层的数据包过滤

* 面向应用层的用户接口

libpcap的包捕获机制就是在数据链路层加一个旁路处理。当一个数据包到达网络接口时，libpcap首先利用链路层PF\_PACKET原始套接字从链路层驱动程序中获得该数据包的拷贝，再通过Tap函数将数据包发给BPF过滤器。BPF过滤器根据用户已经定义好的过滤规则对数据包进行逐一匹配，匹配成功则放入内核缓冲区，并传递给用户缓冲区，匹配失败则直接丢弃。如果没有设置过滤规则，所有数据包都将放入内核缓冲区，并传递给用户层缓冲区。所以整个过程并不干扰系统自身的网路协议栈的处理。

libpcap使用流程

决定对那一个接口进行嗅探，如eth0。我们也可以用一个字符串来定义这个设备。

初始化pcap。使用文件句柄传入需要嗅探的设备。同时支持多个设备的嗅探。

设置BPF. 创建一个规则集合，编译并且使用它。这个过程分为三个阶段: 1.规则集合被置于一个字符串内，并且被转换成能被pcap读的格式。2.编译该规则（就是调用一个不被外部程序使用的函数）。3.告诉pcap使用它来过滤数据包。

pcap进入它的主循环。在这个阶段内pcap一直工作到它接收了所有我们想要的包为止。每当它收到一个包（或者多个数据包）就调用另一个已经定义好的函数，这个函数可以做我们想要的任何工作，比如它可以剖析包的上层协议信息并给用户打印出结果，它可以将结果保存为一个文件，或者什么也不作。

在嗅探到所需的数据后，我们要关闭会话并结束。

tcpdump

tcpdump命令：



$ tcpdump --help

tcpdump: invalid option -- '-'

tcpdump version 4.5.1

libpcap version 1.5.3

Usage: tcpdump \[-aAbdDefhHIJKlLnNOpqRStuUvxX\] \[ -B size \] \[ -c count \]

        \[ -C file\_size \] \[ -E algo:secret \] \[ -F file \] \[ -G seconds \]

        \[ -i interface \] \[ -j tstamptype \] \[ -M secret \]

        \[ -P in\|out\|inout \]

        \[ -r file \] \[ -s snaplen \] \[ -T type \] \[ -V file \] \[ -w file \]

        \[ -W filecount \] \[ -y datalinktype \] \[ -z command \]     \[ -Z user \] \[ expression \]

1

2

3

4

5

6

7

8

9

10

tcpdump选项可划分为四大类型：控制tcpdump程序行为，控制数据怎样显示，控制显示什么数据，以及过滤命令。



控制程序行为

这一类命令行选项影响tcpdump程序行为，如包括数据收集的方式:-w选项允许用户将输出重定向到一个文件，之后可通过-r选项将捕获数据显示出来。



如果用户知道需要捕获的报文数量或对于数量有一个上限，可使用-c选项。则当达到该数量时程序自动终止，而无需使用kill命令或Ctrl-C。下例中，收集到100个报文之后tcpdump终止： 

bsd1\# tcpdump -c 100



如果用户在多余一个网络接口上运行tcpdump，用户可以通过-i选项指定接口。在不确定的情况下，可使用ifconfig –a来检查哪一个接口可用及对应哪一个网络。例如，一台机器有两个接口，eth0接口IP地址192.168.0.1，eth1接口IP地址192.168.0.2。要捕捉192.168.0.1网络的数据流，使用以下命令：



bsd1\# tcpdump -i eth0

1

2

没有指定接口时，tcpdump默认为最低编号接口。



-p选项将网卡接口设置为非混杂模式。这一选项理论上将限制为捕获接口上的正常数据流——来自或发往主机，多播数据，以及广播数据。



-s选项控制数据的截取长度。通常，tcpdump默认为一最大字节数量并只会从单一报文中截取到该数量长度。实际字节数取决于操作系统的设备驱动。通过默认值来截取合适的报文头，而舍弃不必要的报文数据。减少数据量。



如果用户需截取更多数据，通过-s选项来指定字节数。也可以用-s来减少截取字节数。对于少于或等于200字节的报文，以下命令会截取完整报文：



\# tcpdump -s200

1

2

更长的报文会被缩短为200字节。



控制信息如何显示

-a，-n，-N和-f选项决定了地址信息是如何显示的。-a选项强制将网络地址显示为名称，-n阻止将地址显示为名字，-N阻止将域名转换。-f选项阻止远端名称解析。下例中，从sloan.lander.edu \(205.153.63.30\) ing远程站点，分别不加选项，-a，-n，-N，-f。（选项-c1限制抓取1个报文）



\# tcpdump -c1 host 192.31.7.130

tcpdump: listening on xl0

14:16:35.897342 sloan.lander.edu &gt; cio-sys.cisco.com: icmp: echo request

\# tcpdump -c1 -a host 192.31.7.130

tcpdump: listening on xl0

14:16:14.567917 sloan.lander.edu &gt; cio-sys.cisco.com: icmp: echo request

\# tcpdump -c1 -n host 192.31.7.130

tcpdump: listening on xl0

14:17:09.737597 205.153.63.30 &gt; 192.31.7.130: icmp: echo request

\# tcpdump -c1 -N host 192.31.7.130

tcpdump: listening on xl0

14:17:28.891045 sloan &gt; cio-sys: icmp: echo request

\# tcpdump -c1 -f host 192.31.7.130

tcpdump: listening on xl0

14:17:49.274907 sloan.lander.edu &gt; 192.31.7.130: icmp: echo request

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

默认为-a选项。



-t和-tt选项控制时间戳的打印。-t选项不显示时间戳而-tt选项显示无格式的时间戳。以下命令显示了tcpdump命令无选项，-t选项，-tt选项的同一报文：



12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 \(DF\)

sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 \(DF\)

934303014.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 \(DF\)

1

2

3

控制显示什么数据

可以通过-v和-vv选项来打印更多详细信息。例如，-v选项将会打印TTL字段。要显示较少信息，使用-q，或quiet选项。一下为同一报文分别使用-q选项，无选项，-v选项，和-vv选项的输出。



12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: tcp 0 \(DF\)

12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 \(DF\)

12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 \(DF\) \(ttl 128, id 45836\)

12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 \(DF\) \(ttl 128, id 45836\)

1

2

3

4

-e选项用于显示链路层头信息。上例中-e选项的输出为：



12:36:54.772066 0:10:5a:a1:e9:8 0:10:5a:e3:37:c ip 60:

sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 \(DF\)

1

2

0:10:5a:a1:e9:8是sloan.lander.edu中3Com卡的以太网地址，0:10:5a:e3:37:c是205.153.63.238中3Com卡的以太网地址。



-x选项将报文以十六进制形式dump出来，排除了链路层报文头。-x和-vv选项报文显示如下：



13:57:12.719718 bsd1.lander.edu.1657 &gt; 205.153.60.5.domain: 11587+ A? www.microsoft.com. \(35\) \(ttl 64, id 41353\)

                         4500 003f a189 0000 4011 c43a cd99 3db2

                         cd99 3c05 0679 0035 002b 06d9 2d43 0100

                         0001 0000 0000 0000 0377 7777 096d 6963

                         726f 736f 6674 0363 6f6d 0000 0100 01

1

2

3

4

5

过滤

要有效地使用tcpdump，掌握过滤器非常必要的。过滤允许用户指定想要抓取的数据流，从而用户可以专注于感兴趣的数据。



如果用户很清楚对何种数据流不感兴趣，可以将这部分数据排除在外。如果用户不确定需要什么数据，可以将源数据收集到文件之后在读取时应用过滤器。实际应用中，需要经常在两种方式之间转换。



简单的过滤器是加在命令行之后的关键字。但是，复杂的命令是由逻辑和关系运算符构成的。对于这样的情况，通常最好用-F选项将过滤器存储在文件中。例如，假设testfilter 是一个包含过滤主机205.153.63.30的文本文件，之后输入tcpdump –F testfilter等效于输入命令tcpdump host 205.153.63.30。通常，这一功能只在复杂过滤器时使用。但是，同一命令中命令行过滤器和文件过滤器不能混用。



地址过滤

过滤器可以按照地址选择数据流。例如，考虑如下命令：



\# tcpdump host 205.153.63.30

1

2

该命令抓取所有来自以及发往IP地址205.153.63.30的主机。主机可以通过名称或IP地址来选定。虽然指定的是IP地址，但抓取数据流并不限于IP数据流，实际上，过滤器也会抓到ARP数据流。如果要限定仅抓取特定协议的数据流就需要更复杂的过滤器了。



有若干种方式可以指定和限制地址，下例是通过机器的以太网地址来选择数据流：



\# tcpdump ether host 0:10:5a:e3:37:c

1

2

数据流可进一步限制为单向，分别用src或dst指定数据流的来源或目的地。下例显示了发送到主机205.153.63.30的数据流：



\# tcpdump dst 205.153.63.30

1

2

注意到本例中host被省略了。在某些例子中省略是没问题的，但添加这些关键字通常更安全些。



广播和多播数据相应可以使用broadcast和multicast。由于多播和广播数据流在链路层和网络层所指定的数据流是不同的，所以这两种过滤器各有两种形式。过滤器ether multicast抓取以太网多播地址的数据流，ip multicast抓取IP多播地址数据流。广播数据流也是类似的使用方法。



注意多播过滤器也会抓到广播数据流。



除了抓取特定主机以外，还可以抓取特定网络。例如，以下命令限制抓取来自或发往205.153.60.0的报文：



\# tcpdump net 205.153.60

1

2

以下命令也可以做同样的事情：



\# tcpdump net 205.153.60.0 mask 255.255.255.0

1

2

而以下命令由于最后的.0就无法正常工作：



\# tcpdump net 205.153.60.0

1

2

协议及端口过滤

限制抓取指定协议如IP或TCP。还可以限制建立在这些协议之上的服务，如DNS或RIP。这类抓取可以通过三种方式进行：使用tcpdump关键字，通过协议关键字proto，或通过服务使用port关键字。



一些协议名能够被tcpdump识别到因此可通过关键字来指定。以下命令限制抓取IP数据流：



\# tcpdump ip

1

2

当然，IP数据流包括TCP数据流，UDP数据流，等等。



如果仅抓取TCP数据流，可以使用：



\# tcpdump tcp

1

2

tcpdump可识别的关键字包括ip, igmp, tcp, udp, and icmp。



有很多传输层服务没有可以识别的关键字。在这种情况下，可以使用关键字proto或ip proto加上/etc/protocols能够找到的协议名或相应的协议编号。例如，以下两种方式都会查找OSPF报文：



bsd1\# tcpdump ip proto ospf

bsd1\# tcpdump ip proto 89

1

2

3

内嵌的关键字可能会造成问题。下面的例子中，无法使用tcp关键字，或必须使用数字。例如，下面的例子是正常工作的：



bsd\#1 tcpdump ip proto 6

1

2

另一方面，不能使用proto加上tcp:



bsd\#1 tcpdump ip proto tcp

1

2

会产生问题。



对于更高层级的建立于底层协议之上的服务，必须使用关键字port。以下两者会采集DNS数据流：



\#1 tcpdump port domain

\#1 tcpdump port 53

第一条命令中，关键字domain能够通过查找/etc/services来解析。在传输层协议有歧义的情况下，可以将端口限制为指定协议。考虑如下命令：



\#1 tcpdump udp port domain

这会抓取使用UDP的DNS名查找但不包括使用TCP的DNS zone传输数据。而之前的两条命令会同时抓取这两种数据。

